from abc import ABC, abstractmethod
from typing import Any, Callable, TypeVar, Generic, Protocol, Optional


class VertexComparable(Protocol):
    def __init__(self, *args: Any, **kwargs: Any): ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...

class VertexComputable(VertexComparable, Protocol):
    def __add__(self, other: Any) -> Any: ...
    def __sub__(self, other: Any) -> Any: ...
    def __mul__(self, other: Any) -> Any: ...
    def __truediv__(self, other: Any) -> Any: ...
    def __floordiv__(self, other: Any) -> Any: ...
    def __mod__(self, other: Any) -> Any: ...
    def __pow__(self, other: Any) -> Any: ...
    def __and__(self, other: Any) -> Any: ...
    def __or__(self, other: Any) -> Any: ...
    def __xor__(self, other: Any) -> Any: ...


T = TypeVar('T', bound=VertexComparable)
T_co = TypeVar('T_co', bound=VertexComputable, covariant=True)

class Vertex(Generic[T_co], ABC):

    @abstractmethod
    def __init__(self, value: T_co):
        self._value: T_co = value

    @property
    def value(self) -> T_co:
        return self._value
    
class VertexOp(Protocol):
    def __call__(self, value: Vertex[T_co], *args: Any, **kwargs: Any) -> Vertex[T_co]: ...
